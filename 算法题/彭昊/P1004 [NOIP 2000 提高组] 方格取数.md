[P1004 [NOIP 2000 提高组] 方格取数 - 洛谷](https://www.luogu.com.cn/problem/P1004)

#### 思路：

看到这道题，我首先想到的是同样取同样最大值，但是只走一次的dp模板题。那么走两次有什么不一样呢？如果两次走了同一个格子，那么这个格子的数只会加一次。那么就可以等效转换成两个人同时走，如果格子相同，这个格子的数就只加一次，不同，就两个格子的数都相加。那么就又可以用动态规划了



#### 题解：

因为两个人同时出发，那么走的步数一定相同。也就是说两个人的的横纵坐标之和一定时刻相同。那么原本用四个变量才能表示的两个人坐标用三个变量就可以确定。我是$i$、$j$表示第一人的横纵坐标，$k$表示第二人的横坐标，那么第二人的纵坐标就是$i+j-k$。由此可以得出状态转移方程为：

```c++
dp[i][j][k] = max(
    {
            dp[i - 1][j][k],dp[i][j - 1][k],
            dp[i - 1][j][k - 1],dp[i][j - 1][k - 1]
    }) + board[i][j] + (i == k ? 0 : board[k][i + j - k]);
```

$i$、$j$的范围都很好确定，而由于第二人纵坐标是$i + j - k$，所以$k$的范围需要单独求

假设第二人的纵坐标为$m$，那么

$$
\begin{cases}
k + m = i + j \\
1\le k \le N \\
1\le m \le N 
\end{cases}
$$

求k的范围，得

$$
max(i+j-N,1)\le k \le min(i+j-1,N)
$$

#### 代码

```c++
#if 1
#include<bits/stdc++.h>
using namespace std;
int N;
vector<vector<int>> board(10, vector<int>(10, 0));
vector<vector<vector<int>>> dp(10, vector<vector<int>>(10, vector<int>(10, 0)));
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> N;
    while (1)
    {
        int xx, yy, num;
        cin >> xx >> yy >> num;
        if ((xx || yy || num) == 0) { break; }
        board[xx][yy] = num;
    }

    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= N; j++)
        {
            for (int k = max ( i + j - N ,1); k <= min(i + j - 1,N); k++)
            {
                dp[i][j][k] = max(
                    {
                            dp[i - 1][j][k],dp[i][j - 1][k],
                            dp[i - 1][j][k - 1],dp[i][j - 1][k - 1]
                    }) + board[i][j] + (i == k ? 0 : board[k][i + j - k]);
            }
        }
    }
    cout << dp[N][N][N] << endl;
    return 0;
}
#endif
```


