[P1219 [USACO1.5] 八皇后 Checker Challenge - 洛谷](https://www.luogu.com.cn/problem/P1219)

#### 思考

肯定是用深度搜索

一开始我用一个n*n的bool数组表示棋盘，发现超时了。然后想到了用三个bool数组分别表示列和两个对角线的占用情况。

#### 题解

对于每一行，挨个判断每个格子是否可以放，如果可以，先判断是否放完每一列，放完了就cout，没放完就递归判断下一列。回溯后再把那三个bool数组还原

#### 代码

```c++
#if 1
#include<bits/stdc++.h>
#define ll long long
#define ve vector<int>
using namespace std;
int n;
ve pos(13, 0);
ve x(13, 0);
ve xie1(25, 0);
ve xie2(25, 0);
int times = 0;
ll ans = 0;
void dfs(int c)
{
    for (pos[c] = 0; pos[c] < n; pos[c]++)
    {
        int now = pos[c];
        if (x[now] == 0 && xie1[now + c] == 0 && xie2[now - c + n - 1] == 0)//符合要求
        {
            x[now] = 1;
            xie1[now + c] = 1;
            xie2[now - c + n - 1] = 1;
            if (c == n - 1)//放完了
            {
                ans++;
                if (times < 3)
                {
                    times++;
                    for (int i = 0; i < n; i++)
                    {
                        cout << pos[i] + 1 << " ";
                    }cout << endl;
                }
            }
            else { dfs(c + 1); }
            x[now] = 0;
            xie1[now + c] = 0;
            xie2[now - c + n - 1] = 0;
        }
    }
    return;

}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> n;
    dfs(0);
    cout << ans;
    system("pause");
    return 0;
}
#endif
```
