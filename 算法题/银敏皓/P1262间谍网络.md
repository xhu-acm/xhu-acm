[P1262间谍网络](https://www.luogu.com.cn/problem/P1262)

自己做题时的思考：

​	这道题，有两种情况：`YES` / `NO`。

​	仔细想一下，`NO` 是很容易处理的，标记一下可以被收买的间谍，然后让每个间谍为起始顶点进行DFS图搜，能搜到的间谍都是可控制的，对于可控制的间谍打上标记，最后遍历 1 ~ n ，如果中途存在一个点没有被标记，则为 `NO`。

​	先判定是否为`NO`，如果不是 `NO` 那么必然是`YES`，则必然可以控制所有间谍；

​	对于 `YES` 的情况，需要我们花费最小的价钱来控制所有的间谍，先会想到需要保证买的每个间谍，只可能被买，没有其他的间谍指向他，但是呢，图中可能会出现环（强连通分量）。所以，考虑用 SCC 缩点，强连通分量就被缩成点，只需要**买入度为0**的点内花费最小的那个间谍。

​	SCC缩点完过后，将所有入度为 0 的点的花费最小相加，就是答案了；



题解：

​	`wt[N]` 定义每个顶点的花费，为 `INF` 则不能收买；`wtm[N]` 记录序号为 `i` 的SCC的最小花费；

​	`vis[N]` 用来打标记； `din[N]` 记录入度的数量；

​	开始时，就是正常地读入信息，建图，记录 `wt[i]` 。然后进行 `dfs` 判断是否为 `NO`，不是则继续。

​	用SCC算法把整个图跑一遍，在记录SCC时顺便可以记录此SCC的最小花费，即`wtm[i]`。

​	过后，遍历所有的边，记录每个 SCC 的 `din[i]` ，最后将 `din[i]==0` 的 SCC 的 `wtm[i]` 加起来。



代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
#define OFF ios::sync_with_stdio(0),cin.tie(0);
const int N = 4e3 + 5;
int low[N],dfn[N],tot;
int stk[N],instk[N],top;
int n,p,r;
vector<int> e[N];
int scc[N],cnt;
int din[N];
int wt[N],wtm[N],vis[N];
const int INF = 1e9;
void tarjan(int x){
    low[x] = dfn[x] = ++tot;
    stk[++top] = x;instk[x] =1;
    for(int y:e[x]){
        if(!dfn[y]){
            tarjan(y);
            low[x] = min(low[x],low[y]);
        }
        else if(instk[y]){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(low[x] == dfn[x]){
        ++cnt;int y;
        do{
            y = stk[top--];instk[y] = 0;
            scc[y] = cnt;
            wtm[cnt] = min(wtm[cnt],wt[y]);// 记录 wtm[]
        }while(y!=x);
    }
}
void dfs(int x){
    if(vis[x])return;
    vis[x] = 1;
    for(int y:e[x]){
        dfs(y);
    }
}
int main(){
    OFF
    cin>>n;
    cin>>p;
    for(int i=1;i<=n;i++)wt[i]=wtm[i] = INF;
    for(int i=1,id,w;i<=p;i++){
        cin>>id>>w;
        wt[id] = w;
    }
    cin>>r;
    for(int i=0,x,y;i<r;i++){
        cin>>x>>y;
        e[x].push_back(y);
    }

    for(int i=1;i<=n;i++){
        if(wt[i]!=INF)dfs(i);
    }

    for(int i=1;i<=n;i++){
        if(!vis[i]){
            cout<<"NO\n"<<i;
            return 0;
        }
    }
    // SCC 跑图
    for(int i=1;i<=n;i++){
        if(!dfn[i])tarjan(i);
    }
    // 记录 din[]
    for(int i=1;i<=n;i++){
        for(int j:e[i]){
            if(scc[j]!=scc[i]){
                din[scc[j]]++;
            }
        }
    }
    long long sum =0;
    for(int i=1;i<=cnt;i++){
        if(din[i]==0){
            sum+=wtm[i];
        }
    }
    cout<<"YES\n"<<sum;
    return 0;
}
```
