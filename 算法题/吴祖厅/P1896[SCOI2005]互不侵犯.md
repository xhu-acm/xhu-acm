# 题解：[P1896 [SCOI2005] 互不侵犯](https://loj.ac/p/2153)

## 1. 题目简述

在 $N \times N$ ($1 \le N \le 9$) 的棋盘中放置 $K$ 个国王，要求它们互不攻击（即任意两个国王不能在横、竖、斜八个方向相邻）。求总共有多少种摆放方案。

## 2. 算法分析

### DFS 暴力搜索

看到棋盘放子问题，直觉反应往往是 **DFS（深度优先搜索）**。我们尝试从 $(0,0)$ 到 $(N-1,N-1)$ 逐个格子决定“放”还是“不放”。

所以很容易就会写出以下代码：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int n;
long long ans = 0;
int grid[10][10];

int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};

// 检查 (x, y) 是否可以放国王
bool check(int x, int y) {
	// 只需要检查左上、上、右上、左四个方向（因为我们是从左上往右下搜的）
	// 其实严格来说，只要检查周围有没有 1 即可
	for (int i = 0; i < 8; i++) {
		int nx = x + dx[i];
		int ny = y + dy[i];
		if (nx >= 0 && nx < n && ny >= 0 && ny < n) {
			if (grid[nx][ny] == 1)
				return false;
		}
	}
	return true;
}

// x, y: 当前考虑的坐标; k: 还需要放几个国王
void dfs(int x, int y, int k) {
	// 边界处理：如果一行搜完了，换下一行
	if (y == n) {
		x++;
		y = 0;
	}

	// 如果搜完了所有格子 (x==n 表示超出了最后一行)
	if (x == n) {
		if (k == 0)
			ans++; // 如果正好放完 K 个，方案数+1
		return;
	}

	// 选择1：当前格子 (x, y) 不放国王 -> 直接去下一个格子
	dfs(x, y + 1, k);

	// 选择2：当前格子 (x, y) 放国王 (前提是这里能放，且还有国王在手)
	if (k > 0 && check(x, y)) {
		grid[x][y] = 1;      // 标记
		dfs(x, y + 1, k - 1); // 递归
		grid[x][y] = 0;      // 回溯（恢复现场）
	} else if (k == 1 && check(x, y)) {
		ans++;
	}
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);
	int k;
	cin >> n >> k;
	// 必须处理 k=0 的特殊情况，通常题目暗示至少放1个，但如果是0，方案是1（空盘）
	if (k == 0) {
		cout << 0;
		return 0;
	}
	// 不过按照题目逻辑，k>=0。
	dfs(0, 0, k);
	cout << ans;
	return 0;
}
```

1. **搜索空间过大**：最坏情况下每个格子都有放或不放两种选择，复杂度接近 $O(2^{N^2})$。当 $N=9$ 时，$2^{81}$ 很大。虽然加了一些神奇剪枝，但对于 $N=9$ 且 $K$ 较大的情况，依然会 **TLE**。
2. **重复计算**：DFS 并没有记录中间状态。比如“第 3 行放了某种方案，剩余 5 个国王”这种情况，可能会被前两行的多种不同组合重复触发，DFS 会把这些完全相同的子问题重复算一遍。

### 记忆化搜索

观察数据范围 $N \le 9$，可以考虑用**状态压缩**，把单行放置国王的状态压缩成一个整数 。

* **状态压缩**：$N$ 很小，我们可以用一个二进制数（0 到 $2^N-1$）来表示一行的摆放状态。例如 $N=5$，二进制 `10100` 表示第 1、3 列放了国王。

因此，我们可以将算法优化为：**按行决策，记录上一行的状态（二进制）和已使用的国王数。**

---

## 3. 核心逻辑与状态定义

### 状态定义

我们需要一个记忆化数组来记录计算过的状态：
`dp[row][state][kings]`

* `row`：当前处理到了第几行。
* `state`：上一行的二进制状态（用于检测冲突）。
* `kings`：还需要放置多少个国王。
* **值**：在该状态下，后续所有行的合法摆放方案总数。

### 预处理

在 $0$ 到 $2^N-1$ 的所有状态中，有很多状态自身就是非法的（即存在左右相邻的国王，如 `1100`）。我们可以在开始搜索前，先把所有**单行合法**的状态筛选出来存入 `vector<int> row`，这样能大幅减少循环次数。

* 检查单行合法：`!((s << 1) & s)` （若存在相邻的 1，与运算结果不为 0）。

### 冲突检测和剪枝

假设当前行数为`row`，上一行状态为 `s`，当前行状态为 `i`，剩余国王数为`k`。如果`dp[row][s][k]`的值不等于`-1`，则说明这个状态已经被搜索过了，直接返回该值就行，达到类似剪枝的效果可以大幅减小搜索时间，否则枚举当前行的状态`i`并继续往下搜索。

1. **垂直方向**：`s & i` （如果同为 1，说明上下正对）。
2. **左上/右下方向**：`(s << 1) & i`。
3. **右上/左下方向**：`(s >> 1) & i`。

如果以上三个结果都为 0，且当前行放置的国王数不超过剩余需要的国王数，则可以继续往下搜索并更新搜索值到`dp[row][s][k]`，这样下次搜索到时就可以直接使用，就不用继续往下搜索了。

---

## 4. AC代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

long long ans = 0;
vector<int> row;//预处理一行内所有合法的状态
int n;

//检查一行内的状态 s 是否合法（没有左右相邻的国王）
bool check(int &s) {
	return !((s << 1) & s);
}

//计算二进制中1的个数
int sum(int &s) {
	int bns = 0;
	for (int i = 0; s >> i > 0; i++) {
		if (s >> i & 1) {
			bns++;
		}
	}
	return bns;
}

long long dfs(vector<vector<vector<long long>>> &dp, int s, int now, int k) {
	if (now > n) {
		return 0;
	}
	if (dp[now][s][k] != -1) {
		return dp[now][s][k];
	}
	long long bns = 0;
	for (int i : row) {
		//检查上下行冲突并检查剩余国王数
		if (s & i || (s << 1) & i || (s >> 1) & i || k - sum(i) < 0) {
			continue;
		}
		//如果还剩余国王则继续枚举下一行
		if (k - sum(i) > 0) {
			bns += dfs(dp, i, now + 1, k - sum(i));
		} else if (!(k - sum(i))) {
			bns++;//已经没有国王则答案+1
		}
	}
	return dp[now][s][k] = bns;
}

int main() {
	int k;
	cin >> n >> k;

	//一行有多少种摆放方式
	int num = (1 << n);
	vector<vector<vector<long long>>> dp(n + 1, vector<vector<long long>>(num, vector<long long>(k + 1,
	                                     -1))); //dp[行号][上一行状态][剩余国王数]初始化为-1
	//预处理所有合法的单行状态
	for (int s = 0; s < num; s++) {
		if (check(s) && sum(s) <= k) {
			row.push_back(s);
		}
	}

	//枚举第一行的所有可能状态
	for (int s : row) {
		ans += dfs(dp, s, 2, k - sum(s));
	}

	cout << max(ans, (long long)1) << endl;
	return 0;
}
```