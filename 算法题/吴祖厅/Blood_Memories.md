\# \[Blood Memories](https://qoj.ac/contest/2567/problem/14707)



\## 1. 题目大意



Panda 正在操控一个由 $n$ 个角色组成的队伍与恶魔军队战斗。



\- \*\*角色数量\*\*：$n$ 非常小 ($1 \\le n \\le 6$)。

\- \*\*回合数\*\*：$R$ 非常大 ($1 \\le R \\le 10^9$)。

\- \*\*能量限制\*\*：每回合有固定 $m$ 点 AP。

\- \*\*技能机制\*\*：

&nbsp; - 角色 $i$ 造成 $a\_i$ 伤害。

&nbsp; - 基础消耗为 $c\_i$。

&nbsp; - \*\*连击惩罚\*\*：如果角色在上一回合使用了技能，本回合消耗变为 $c\_i + k$；否则消耗重置为 $c\_i$。

\- \*\*目标\*\*：在 $R$ 回合内，求最大总伤害。



---



\## 2. 解题思路



\### 2.1 观察数据范围



题目的关键突破点在于数据范围：



1\. \*\*$n \\le 6$\*\*：这是一个极小的数字，暗示我们可以使用状态压缩，将每一回合角色的行动状态用一个整数表示（$0$ 到 $2^n-1$）。

2\. \*\*$R \\le 10^9$\*\*：回合数极大，普通的动态规划 $O(R \\cdot 2^n)$ 肯定会超时。这强烈提示我们需要使用 $O(\\log R)$ 级别的算法，通常是\*\*矩阵快速幂\*\*。



\### 2.2 状态定义与转移



由于每回合技能的消耗仅取决于\*\*上一回合\*\*该角色是否使用了技能，这满足\*\*马尔可夫性\*\*（无后效性）。



我们可以定义状态：



\- 用一个 $n$ 位的二进制数 $S$ 表示某一回合的决策。第 $i$ 位为 1 表示角色 $i$ 使用技能，为 0 表示不使用。

\- 总共有 $L = 2^n$ 种可能的状态。



我们需要构建一个转移矩阵 $A$，大小为 $L \\times L$。



\- $A\[u]\[v]$ 表示：\*\*如果上一回合的状态是 $u$，本回合采用状态 $v$，本回合能造成的最大伤害。\*\*

\- 如果状态 $v$ 在上一回合状态为 $u$ 的情况下，总 AP 消耗超过了 $m$，则是非法转移，我们将 $A\[u]\[v]$ 设为负无穷（代码中为 `-LONG\_LONG\_MAX`）。



\*\*消耗计算逻辑\*\*：

对于状态 $v$ 中的每一个角色 $p$（即 $v$ 的第 $p$ 位为 1）：



\- 基础消耗：$c\_p$

\- 额外惩罚：如果上一回合状态 $u$ 的第 $p$ 位也是 1，则额外消耗 $k$。



\### 2.3 广义矩阵乘法（Max-Plus Algebra）



通常的矩阵乘法用于计算路径计数等线性递推关系，定义为：



$$

C\_{ij} = \\sum\_{k} (A\_{ik} \\times B\_{kj})

$$



但在本题中，我们需要求的是\*\*最大值\*\*，且伤害是\*\*累加\*\*的。这属于\*\*广义矩阵乘法\*\*（在 $(\\max, +)$ 半环上）。

定义新的矩阵运算 $C = A \\otimes B$：



$$

C\_{ij} = \\max\_{0 \\le p < L} (A\_{ip} + B\_{pj})

$$



\*\*物理含义\*\*：



\- $A\_{ip}$：从状态 $i$ 经过若干回合到达状态 $p$ 的最大伤害。

\- $B\_{pj}$：从状态 $p$ 经过若干回合到达状态 $j$ 的最大伤害。

\- $A\_{ip} + B\_{pj}$：两段路径拼接后的总伤害。

\- $\\max$：枚举所有中间状态 $p$，取最优解。



\### 2.4 结合矩阵快速幂



由于这种广义矩阵乘法满足\*\*结合律\*\*（即 $(A \\otimes B) \\otimes C = A \\otimes (B \\otimes C)$），我们可以使用快速幂算法来加速计算。



我们需要计算 $A^R$（表示经过 $R$ 个回合）。

最终答案即为：从初始状态（第 0 回合无人行动，即状态 0）出发，经过 $R$ 回合后到达任意状态的最大值。

即：$\\max\_{0 \\le i < L} (A^R)\[0]\[i]$。



---



\## 3. 代码解析 (基于 DuanMen.txt)



\### 3.1 初始化与矩阵构建



代码首先读取输入并初始化邻接矩阵 `A`。



```cpp

int L = 1 << n; // 状态总数，最大 2^6 = 64

// ... 初始化 A 为全 0 或负无穷 ...



for (int i = 0; i < L; i++) { // 上一回合状态 (u)

&nbsp;   for (int j = 0; j < L; j++) { // 当前回合状态 (v)

&nbsp;       long long cost = 0;

&nbsp;       long long damage = 0;

&nbsp;       for (int p = 0; p < n; p++) {

&nbsp;           if (j >> p \& 1) { // 如果当前回合使用了角色 p

&nbsp;               cost += node\[p].c;

&nbsp;               if (i >> p \& 1) { // 如果上一回合也使用了，加惩罚 k

&nbsp;                   cost += k;

&nbsp;               }

&nbsp;               damage += node\[p].a;

&nbsp;           }

&nbsp;       }

&nbsp;       // 记录伤害，如果超支则设为负无穷

&nbsp;       if (cost > m) A\[i]\[j] = -LONG\_LONG\_MAX;

&nbsp;       else A\[i]\[j] = damage;

&nbsp;   }

}

```



这段代码构建了\*\*一步转移矩阵\*\*。$A\[i]\[j]$ 存储了从状态 $i$ 转移到 $j$ 单回合获得的伤害。



\### 3.2 矩阵快速幂逻辑



代码中并没有封装独立的矩阵乘法函数，而是直接写在了 `while` 循环里。

这里有一个细节：



```cpp

ans = A; // 初始化答案为走了一步的情况

R--;     // 剩余需要走的步数

while (R > 0) {

&nbsp;   if (R \& 1) {

&nbsp;       // T = ans \* A (广义乘法)

&nbsp;       // 更新 ans

&nbsp;   }

&nbsp;   // A = A \* A (倍增)

&nbsp;   R >>= 1;

}

```



\*\*为什么这样做？\*\*

初始时，游戏还没开始，可以视为“第 0 回合”，状态必然是 0（因为没有任何前置技能使用记录）。



\- 第一回合的消耗计算基于“上一回合状态是 0”。

\- 矩阵 `A` 的第 0 行 (`A\[0]\[...]`) 正好代表了：前一状态为 0 时，转移到各种状态的伤害。

\- 所以 `ans` 初始设为 `A`，代表已经模拟了第 1 回合。

\- 随后我们需要再模拟 $R-1$ 次转移，利用矩阵快速幂将 $A$ 自乘 $R-1$ 次并累积到 `ans` 上。



\### 3.3 核心乘法操作



```cpp

// 对应公式：T\[i]\[j] = max(ans\[i]\[p] + A\[p]\[j])

T\[i]\[j] = -LONG\_LONG\_MAX;

for (int p = 0; p < L; p++) {

&nbsp;   T\[i]\[j] = max(T\[i]\[j], ans\[i]\[p] + A\[p]\[j]);

}

```



这就是标准的 $(\\max, +)$ 矩阵乘法实现。



\### 3.4 最终答案



```cpp

long long bns = 0;

for (int i = 0; i < L; i++) {

&nbsp;   bns = max(bns, ans\[0]\[i]);

}

```



由于我们关心的是从初始状态（0）开始，经过 $R$ 回合后的最大值，所以只需要查看结果矩阵 `ans` 的第 0 行，取其中最大的值即可。



---



\## 4. 复杂度分析



\- \*\*时间复杂度\*\*：

&nbsp; - 矩阵大小 $L = 2^n$。

&nbsp; - 矩阵乘法一次的复杂度为 $O(L^3)$。

&nbsp; - 快速幂需要进行 $O(\\log R)$ 次乘法。

&nbsp; - 总复杂度：$O((2^n)^3 \\log R) = O(8^n \\log R)$。

&nbsp; - 代入 $n=6, R=10^9$：$2^{18} \\approx 2.6 \\times 10^5$，$\\log R \\approx 30$。计算量约为 $10^7$ 级别，对于 3 秒的时限非常充裕。

\- \*\*空间复杂度\*\*：

&nbsp; - 需要存储几个 $L \\times L$ 的矩阵，空间极小 ($64 \\times 64$)。



\## 5. 总结



本题是一道经典的\*\*矩阵快速幂优化 DP\*\* 题目。



1\. 利用 $n$ 很小的特点进行\*\*状态压缩\*\*。

2\. 将 DP 转移方程 $dp\[t]\[j] = \\max(dp\[t-1]\[i] + \\text{cost}(i, j))$ 转化为\*\*广义矩阵乘法\*\*。

3\. 利用矩阵快速幂将线性时间的模拟优化为对数时间。



\*\*关键点回顾\*\*：



\- 矩阵乘法不仅仅是“乘和加”，在满足结合律的半环结构上（如 $\\max/+$ 或 $\\min/+$）都可以使用快速幂。

\- 状态压缩不仅用于存储状态，也是构建矩阵索引的基础。



