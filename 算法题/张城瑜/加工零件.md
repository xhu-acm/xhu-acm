题目链接:https://www.luogu.com.cn/problem/P5663
题目描述
	凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很神奇。工厂里有 n 位工人，工人们从 1∼n 编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。
	如果 x 号工人想生产一个被加工到第 L(L>1) 阶段的零件，则所有与 x 号工人有传送带直接相连的工人，都需要生产一个被加工到第 L−1 阶段的零件（但 x 号工人自己无需生产第 L−1 阶段的零件）。
	如果 x 号工人想生产一个被加工到第 1 阶段的零件，则所有与 x 号工人有传送带直接相连的工人，都需要为 x 号工人提供一个原材料。
	轩轩是 1 号工人。现在给出 q 张工单，第 i 张工单表示编号为 ai的工人想生产一个第 Li阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！

	输入格式
	第一行三个正整数 n，m 和 q，分别表示工人的数目、传送带的数目和工单的数目。
	接下来 m 行，每行两个正整数 u 和 v，表示编号为 u 和 v 的工人之间存在一条零件传输带。保证 u=v。
	接下来 q 行，每行两个正整数 a 和 L，表示编号为 a 的工人想生产一个第 L 阶段的零件。
	
	输出格式
	共 q 行，每行一个字符串 Yes 或者 No。如果按照第 i 张工单生产，需要编号为 1 的轩轩提供原材料，则在第 i 行输出 Yes；否则在第 i 行输出 No。
	
	输入输出样例
	输入 
	3 2 6
	1 2
	2 3
	1 1
	2 1
	3 1
	1 2
	2 2
	3 2
	输出
	No
	Yes
	No
	Yes
	No
	Yes
	输入
	5 5 5
	1 2
	2 3
	3 4
	4 5
	1 5
	1 1
	1 2
	1 3
	1 4
	1 5
	输出
	No
	Yes
	No
	Yes
	Yes
	说明/提示
	样例 1 说明
	编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。
	编号为 2 的工人想生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。
	编号为 3 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。
	编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零 件，需要编号为 1 和 3 的工人提供原材料。
	编号为 2 的工人想生产第 2 阶段的零件，需要编号为 1 和 3 的工人生产第 1 阶段的零件，他/她们都需要编号为 2 的工人提供原材料。
	编号为 3 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。

	样例 2 说明
	编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 和 5 的工人提供原材料。
	编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 和 5 的工人生产第 1 阶段的零件，需要编号为 1,3,4 的工人提供原材料。
	编号为 1 的工人想生产第 3 阶段的零件，需要编号为 2 和 5 的工人生产第 2 阶段的零件，需要编号为 1,3,4 的工人生产第 1 阶段的零件，需要编号为 2,3,4,5 的工人提供原材料。
	编号为 1 的工人想生产第 4 阶段的零件，需要编号为 2 和 5 的工人生产第 3 阶段的零件，需要编号为 1,3,4 的工人生产第 2 阶段的零件，需要编号为 2,3,4,5 的工人生产第 1 阶段的零件，需要全部工人提供原材料。
	编号为 1 的工人想生产第 5 阶段的零件，需要编号为 2 和 5 的工人生产第 4 阶段的零件，需要编号为 1,3,4 的工人生产第 3 阶段的零件，需要编号为 2,3,4,5 的工人生产第 2 阶段的零件，需要全部工人生产第 1 阶段的零件，需要全部工人提供原材料。

	数据规模与约定
	共 20 个测试点。
	对所有测试点保证 1≤u,v,a≤n。
	测试点 1∼4，1≤n,m≤1000，q=3，L=1。
	测试点 5∼8，1≤n,m≤1000，q=3，1≤L≤10。
	测试点 9∼12，1≤n,m,L≤1000，1≤q≤100。
	测试点 13∼16，1≤n,m,L≤1000，1≤q≤10^5
	测试点 17∼20，1≤n,m,q≤10^5,1≤L≤10^9


[思路过程]:
	首先可以确定:这些工人和传送带构建出了一个无向图
	假设工人A仅与工人B连接,同时工人B仅与工人A链接,A要生产n级零件(假设n非常大)
	那么依次为:
		1:工人B生产n-1级零件;
		2:工人A生产n-2级零件;
		3:工人B生产n-3级零件;
	所以:零件传递过程就像是波从a向外扩散，经过L-1步到达的工人需要提供原材料
	即认为:这个问题可以转化为：当a号工人想生产第L阶段零件时，需要传播L-1步。我们需要判断是否存在一条从a到1号工人邻居的路径，使得：

		1:路径长度 ≤ L-1;
		2:路径长度的奇偶性与L-1相同;
	所以我们可以用bfs对无向图遍历,分别对奇数与偶数求出最短路径
代码如下:
#include <string>
#include <iostream>
#include <vector>
#include<deque>
#include <algorithm>
using namespace std;

int main()
{
    cin.tie(0);
    ios::sync_with_stdio(false);
    cout.tie(0);

    int n, m, q;
    cin >> n >> m >> q;

    // 构建邻接表表示图
    vector<vector<int>> adj(n);
    for (int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        a--; b--;  // 转换为0-based索引
        adj[a].push_back(b);
        adj[b].push_back(a);  // 无向图，双向添加
    }
    
    const int INF = 1e9;
    // dist0[i]: 从1号工人的邻居到节点i的偶数距离最短路径长度
    // dist1[i]: 从1号工人的邻居到节点i的奇数距离最短路径长度
    vector<int> dist0(n, INF);
    vector<int> dist1(n, INF);

    deque<pair<int, int>> dq;  // BFS队列，存储(节点, 奇偶性)
    
    // 初始化：将所有与1号工人相邻的节点加入队列
    // 这些节点到自己的距离为0（偶数距离）
    for (int neighbor : adj[0]) {
        dist0[neighbor] = 0;
        dq.push_back({ neighbor, 0 });  // 0表示偶数距离
    }

    // BFS计算最短路径
    while (!dq.empty()) {
        auto [u, parity] = dq.front();  // parity: 0表示偶数距离，1表示奇数距离
        dq.pop_front();

        // 根据奇偶性获取当前节点的距离
        int current_dist = (parity == 0) ? dist0[u] : dist1[u];

        // 遍历所有邻居
        for (int v : adj[u]) {
            int new_parity = 1 - parity;  // 奇偶性翻转
            int new_dist = current_dist + 1;  // 距离加1

            // 根据新的奇偶性更新距离
            if (new_parity == 0) {
                if (new_dist < dist0[v]) {
                    dist0[v] = new_dist;
                    dq.push_back({ v, 0 });
                }
            }
            else {
                if (new_dist < dist1[v]) {
                    dist1[v] = new_dist;
                    dq.push_back({ v, 1 });
                }
            }
        }
    }

    // 处理每个查询
    while (q--) {
        int a, L;
        cin >> a >> L;
        a--;  // 转换为0-based索引
        
        int k = L - 1;  // 需要传播的步数

        // 特殊情况处理：如果不需要传播步数，肯定不需要1号工人提供原材料
        if (k < 0) {
            cout << "No\n";
            continue;
        }
        
        // 核心判断逻辑：
        // 根据传播步数k的奇偶性，检查对应的最短距离是否小于等于k
        // 如果存在这样的路径，说明1号工人需要提供原材料
        if (k % 2 == 0) {  // k为偶数
            if (dist0[a] <= k) {
                cout << "Yes\n";
            }
            else {
                cout << "No\n";
            }
        }
        else {  // k为奇数
            if (dist1[a] <= k) {
                cout << "Yes\n";
            }
            else {
                cout << "No\n";
            }
        }
    }

    return 0;
}
复杂度为O(n+m+q)，满足题目数据
利用了BFS和奇偶性判断，避免了每次查询都进行递归或动态规划