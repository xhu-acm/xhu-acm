[方格取数](https://www.luogu.com.cn/problem/P1004#ide)

做题时的思考：
    首先看到题目时，发现它与找一个路径，使路径上数字和最大的非常相似。
    只找一条路径的话：我们用dp[i][j]来表示走到i行j列是的最大数字和，
                    从而用二维dp来解决。
    那我们猜想这个题是否可以用两次二维dp来解决，让第一次最优，再让第二次
    在第一次的情况下最优，最后返回两次的和。
    但着显然有缺陷，最终的情况有可能是第一次取次优解，第二次在此情况取最优解。
    那么这个猜想不正确。
    基于以上，我们可以考虑把两次一起考虑，用dp[i1][j1][i2][j2]来表示第一次走
    到i1行j1列，第二次走到i2行j2列时的最大数字和，考虑到这里的上一步有可能是
    1：第一次右，第二次右；
    2：第一次右，第二次下；
    3：第一次下，第二次右；
    4：第一次下，第二次下；
    那么dp[i1][j1][i2][j2]可以由dp[i1][j1-1][i2][j2-1]、dp[i1][j1-1][i2-1][j2]、dp[i1-1][j1][i2][j2-1]、
    dp[i1-1][j1][i2-1][j2]转移来。
    那么最大数字和就等于这四个最大的情况转移过来，再加上这一步可以取走的数字 。
    对于第一次任意i,j的位置上的数都可以选，第二次要考虑是否第一次走过这里。
    分两种情况
    1、(i1+j1==i2+j2)： 这里说明此时第一次和第二次走的步数相同，假设这一次为第k步
                        那么第二次只需考虑i1，j1的位置，因为对于第一次走的路径的
                        其它位置横纵坐标的和必然与i2+j2不同，那么不存在重合的点。
                        最终如果第k步时两次的点相同，就加一次这个点的数字，否则都加上。
    2、(i1+j1!=i2+j2)：对于这一种情况我没有很好的解决办法，但是我们可以证明它的值不影响最终答案。
                       假设我们最后需要的是dp[i3][j3][i4][j4]，它状态转移方程所需的点都满足此时第一次的步数等于
                       第二次的步数。而这些点所需的状态转移方程的点也都是满足第一次步数等于
                       第二次步数的。不停递归套用这个逻辑我们可以得到所有可以影响dp[i3][j3][i4][j4]的
                       点都满足第一次步数等于的二次步数，那么对于第二种情况的点的值计算错误不影响最终答案。
    那么我们可以建立状态转移方程
    dp[i1][j1][i2][j2]=max(dp[i1][j1-1][i2][j2-1],dp[i1][j1-1][i2-1][j2],dp[i1-1][j1][i2][j2-1],dp[i1-1][j1][i2-1][j2])+((i1,j1)==(i2,j2))?arr[i1][j1] :arr[i1][j1]+arr[i2][j2];
    可以保证最终需要的点计算结果是对的

    但这个dp维度，时间空间复杂都都为(n^4)太高，而且这个状态转移方程并不正确，只是不影响最终结果。
    从上面的分析可这步数k是一个很重要的参数 
    那么基于这个我们建立dp[k][x1][x2]表示第k步时 第一次在(x1,k+2-x1) 第二次在第一次在(x12,k+2-x12)时的数字最大和。
    同样考虑上一步的情况
    1：第一次右，第二次右；dp[k-1][x1-1][x2-1]
    2：第一次右，第二次下；dp[k-1][x1-1][x2]
    3：第一次下，第二次右；dp[k-1][x1][x2-1]
    4：第一次下，第二次下；dp[k-1][x1][x2]
    在考虑这一步的情况  第一次只有第k步时才有可能与第二次的第k重合，其它点如果x相同，则因为步数不同，y一定不同，两点一定不重合，如果x1==y1那么点重合，只取一次这里的值，否则两者皆取。
    dp[k][x1][x2]=max(dp[k-1][x1-1][x2-1],dp[k-1][x1-1][x2-1],dp[k-1][x1][x2-1],dp[k-1][x1][x2])+(x1==x2)?arr[k+2-x1]:arr[k+2-x1]+arr[k+2-x2];
    时间复杂度与空间复杂度都为(n^3)，有需求的话空间复杂度可以用滚动数组优化。

题解：先初始化每个点的数值arr[i][j],准备dp[k][x1][x2];
     从第0步开始遍历dp,一共2(N-1)步子,枚举x1,x2。
     要保证y=k-x+2要大于0 所有如果(x1 > k+1|| x2 > k+1) 跳过这一轮。
     其次如果k==0 那么dp[k][x1][x2]=arr[k+x1+2][x1];
     其他情况用状态转移方程计算

```cpp
#include<iostream>
using namespace std;
int arr[10][10];
int N;
int dp[30][15][15];
void read();
 
int main()
{
	read();
	for (int k = 0; k <= 2 * (N - 1); k++)
	{
		for (int x1 = 1; x1 <=N; x1++)
			for (int x2 = 1; x2 <=N; x2++)
			{
				if (x1 > k+1|| x2 > k+1) continue;
				if (k == 0) { dp[k][x1][x2] = arr[k - x1 + 2][x1];  continue; }
				int temp = max(max(dp[k - 1][x1 - 1][x2 - 1], dp[k - 1][x1 - 1][x2]), max(dp[k - 1][x1][x2 - 1], dp[k - 1][x1][x2]));
				if (x1 == x2) dp[k][x1][x2] = temp + arr[k - x1+2][x1];
				else  dp[k][x1][x2] = temp + arr[k - x1+2][x1]+arr[k-x2+2][x2];
				 
			}
	}
	cout << dp[2 * (N - 1)][N][N];
}
void read()
{
	cin >> N;
	 
	while (true)
	{
		int i, j, val;
		cin >> i >> j >> val;
		if (i == j && j == val && val == 0) break;
		arr[i][j] = val;
	}
	 
}
```
