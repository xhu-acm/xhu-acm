# 题解

题链接：[Problem - D - Codeforces](https://codeforces.com/contest/2184/problem/D)



做题思考：$1<=n,k<=1e9$，范围很大，考虑能不能尝试打表找到规律，如果没有规律，考虑一下Alice怎么赢游戏最快：应该是能除二的时候就除2，不能除二的时候减1。

那么对于一个数x，用上面的操作，和x的什么性质有关：观察x的二进制，除二相当于对该数进行右移操作，减1相当于把0位上的1减去，然后x又能进行除2（右移）操作，这样就能够算出x变到0最多需要多少步，x变为0的步数等于x的二进制最高位i加上x的二进制含1的个数j。

但是题目问的是从1-n的有多少个数满足题目要求，因此不能暴力算，应该考虑dp或者组合数（计数问题，一般来说数据量大不能暴力又找不到规律时都可能用这两种方法）。考虑dp时，在二进制下，设x的最高位为i，考虑能否从最高位为i-1、i-2、i-3、...0的这些数的结果转移，

例如最高位为3,那么1001可以从0001上面转移，只是贡献多了最高位上的数的差距，因此设计$dp[i][j]$，i表示二进制下最高位为i，j表示要操作j步把数变成0，

转移方程为：

$dp[i][k] += dp[j][k - (i - j + 1)](j < i)$

题解：

```c++
#include <iostream>
using namespace std;
using i64 = long long;
const int inf = 1e9;

int cnt[32][70];
void solve() {
	int n, k;
	cin >> n >> k;

	int c = 0;
	while (n != 1) {
		n /= 2;
		c++;
	}

	int s = 0;
	for (int i = 0; i < c; i++)
		for (int j = k + 1; j <= 65; j++)
			s += cnt[i][j];

	if (c + 1 > k) s++;
	cout << s << '\n';

}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t;
	cin >> t;

	cnt[0][0] = 1;
	cnt[0][1] = 1;
	for (int i = 1; i < 32; i++) // 最高位为i
		for (int j = 0; j < i; j++) // 枚举最高位j(j < i)，转移到i上
			for (int k = i - j + 1; k <= 65; k++) {
				cnt[i][k] += cnt[j][k - (i - j + 1)]; // 转移方程
			}


	while (t--) {
		solve();
	}


	return 0;
}





```

