# PTA 练习题：L2-004 这是二叉搜索树吗？
https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805070971912192&page=1

## 解题思路

### 1. 基本性质

- **前序遍历顺序**：根 → 左子树 → 右子树  
- 在前序序列中：
  - 第一个元素必为当前子树的 **根结点**
  - 后续元素可划分为左子树区间和右子树区间  

### 2. 判断策略

采用递归函数 `dfs(l, r, mirror)`：

- `l, r`：当前处理 `pre[l..r]` 这一段区间  
- `mirror`：
  - `false`：按 **正常 BST** 规则判断  
  - `true` ：按 **镜像 BST** 规则判断  

递归中完成两件事：

1. 判断当前区间是否满足 BST / 镜像 BST 的结构约束  
2. 在验证合法的同时，按后序顺序构造 `post` 数组  

### 3. 分割规则

#### 正常 BST（mirror == false）

- 左子树：值 `< root`  
- 右子树：值 `>= root`  

区间划分：

- `[l+1 , k-1]` → 左子树  
- `[k , r]`     → 右子树  

#### 镜像 BST（mirror == true）

- 左子树：值 `>= root`  
- 右子树：值 `< root`  

区间规则完全相反。

---
## 递归与后序构造

递归顺序：

1. 递归验证左子树  
2. 递归验证右子树  
3. 最后加入根结点  

```text
左 → 右 → 根   （后序遍历顺序）
---

代码内容
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
#define INF 0x3f3f3f3f
const int N =1e5+10;
//int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
//int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1}, dy[] = {0, 1, 1, 1, 0, -1, -1, -1};
vector<int> pre, post;
bool dfs(int l, int r, bool mirror){
	if(l > r) return true;
	int  root = pre[l];
	int k = l + 1;
	
	if(!mirror){
		while( k <= r && pre[k] < root) k++;
		for(int i = k; i <= r; i++){
			if(pre[i] < root) return false;
 		}
	}else{
		while(k <= r && pre[k] >= root) k++;
		for(int i = k; i <= r; i++){
			if(pre[i] >= root) return false;
		}
	}
	if(!dfs(l+1, k-1, mirror)) return false;
	if(!dfs(k, r, mirror)) return false;
	post.push_back(root);
	return true;
}
void solve()
{
	int n;
	cin >> n;
	pre.resize(n);
	for(int i = 0; i < n; i++) cin >> pre[i];
	
	post.clear();
	if(dfs(0, n-1, false)){
		cout << "YES" << endl;
		for(int i = 0; i < post.size(); i++){
			if (i) cout << " ";
			cout << post[i];
		}
		cout << endl;
		return;
	}
	post.clear();
	post.clear();
	if(dfs(0, n-1, true)){
		cout << "YES" << endl;
		for(int i = 0; i < post.size(); i++){
			if (i) cout << " ";
			cout << post[i];
		}
		cout << endl;
		return;
	}
	cout << "NO" << endl;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int t = 1;
	//cin >> t;
	while(t--)
	{
		solve();
	}
	return 0;
}

