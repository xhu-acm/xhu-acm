[吃奶酪](https://www.luogu.com.cn/problem/P1433)

做题时的思考:  求最短路径且n取值较小，考虑用状态压缩DP，用二进制数01表示是否访问过该点

题解:  数据范围 1≤n≤15 比较小，可以用状态压缩DP解决
设一个dp[m][i]数组,其中m是二进制表示，其第几位为1就表示该处的奶酪被吃掉了；i则表示在第几块奶酪处；dp[m][i]=在i处最短距离。
初始化dp数组即让老鼠走一步到对应的点处:dp[1<<i][i]=原点到点i的距离
移动到下一个点求最短距离就是在已知走到i的最短距离和从该点到下一点j距离加上原距离的两个数之间取最小值，状态转移方程为dp[nextm][j]=min(dp[nextm][j],dp[m][i]+i、j两点间距)


最终代码

```
代码内容
#include<bits/stdc++.h>
using namespace std;
const double MAX=1e18;
double calculatedist(double x1, double y1, double x2, double y2) {
    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int n;
    cin>>n;
    vector<double>x(n),y(n);
    for(int i=0;i<n;i++)
        cin>>x[i]>>y[i];
    vector<vector<double>>dist(n,vector<double>(n));
    vector<vector<double>>dp(1<<n,vector<double>(n,MAX));
    vector<double>sdist(n);
    for(int i=0;i<n;i++)
    {
        sdist[i]=calculatedist(0,0,x[i],y[i]);
        for(int j=0;j<n;j++)
        dist[i][j]=calculatedist(x[i],y[i],x[j],y[j]);
    }
    for(int i=0;i<n;i++)
        dp[1<<i][i]=sdist[i];
    for(int m=1;m<(1<<n);m++)
    {
      for (int i = 0; i < n; i++)
      {                  
        if (!(m & (1 << i))) continue;           
        if (dp[m][i] >= MAX) continue;   
            for (int j = 0; j < n; j++)
            {     
                 int nextm=m|(1<<j);
                 if (m & (1 << j)) continue;
                    dp[nextm][j] = min(dp[nextm][j], dp[m][i] + dist[i][j]);
             }
      }
    }
    double res=1e18;
    for(int i=0;i<n;i++)
        res=min(res,dp[(1<<n)-1][i]);
    cout<<fixed<<setprecision(2)<<res<<endl;
    return 0;
} 

```
