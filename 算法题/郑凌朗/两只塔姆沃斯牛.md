[两只塔姆沃斯牛](https://www.luogu.com.cn/problem/P1518)

自己做题时的思考：
	用二维数组存放地图
	用结构体定义牛和农夫的所在位置、当前方向和移动规则。
	移动规则是：查询方向，检查对应方向上是否能行走，不能就改变方向。
	题目怎么说就怎么走，移动代码还是好写的，地图要注意边界，所以用了12*12,用一圈障碍物围起来，免得还要写边界检查。
	判断是否永不相遇，就是看在某一时刻，他们的位置、方向的组合是否在曾经同时出现过。
	我一开始没写好，直接记录位置和方向，存了几个数组，结果要么超时要么不对。
	上网查了一下，发现“专属数”编码，免得复杂记录。
	但仍然超时。检查发现：用for遍历查询是否有重复的数来判断太费时了。
	我去查了一下有什么好方法，
	发现用于查询的话，哈希集的效率比较高，于是我看了哈希集怎么用的，
	用哈希集存储并查询，就不会超时了。
	（改：把switch换成了方向数组,无序set换成了有序set）

题解：
```
#include<iostream>
#include<string>
#include<vector>
#include<set>
using namespace std;
vector<vector <char>> map(12, vector <char>(12, '*'));
const int dx[4] = { 0,1,0,-1 };
const int dy[4] = { -1,0,1,0 };
struct role
{
	int location_X;
	int location_Y;
	int direction = 0;// 0=北，1=东，2=南，3=西

	void checkAndAction()
	{
		int newX = location_X + dx[direction];
		int newY = location_Y + dy[direction];

		if (map[newY][newX] != '*')
		{
			location_X = newX;
			location_Y = newY;
		} else
		{
			direction = (direction + 1) % 4;
		}
	}
};

int main()
{
	std::ios::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);

	char temp;
	role Cow;
	role Farmer;
	int CSX, CSY, FSX, FSY;
	for (int i = 1; i < 11; i++) {
		for (int j = 1; j < 11; j++) {
			cin >> temp;
			if (temp == 'C' || temp == 'F')
			{
				if (temp == 'C')
				{
					Cow.location_X = j;
					CSX = j;
					Cow.location_Y = i;
					CSY = i;
					map[i][j] = '.';
				}
				if (temp == 'F')
				{
					Farmer.location_X = j;
					FSX = j;
					Farmer.location_Y = i;
					FSY = i;
					map[i][j] = '.';
				}
			} else map[i][j] = temp;
		}
	}

	int times = 0; int temp1;
	set<int> maker;
	for (;;)
	{
		temp1 = Farmer.direction + Farmer.location_X * 10 +
			Farmer.location_Y * 100 + Cow.direction * 1000 +
			Cow.location_X * 10000 + Cow.location_Y * 100000;
		auto it = maker.find(temp1);
		if (it != maker.end()) {
			cout << 0;
			break;
		}
		maker.insert(temp1);
		times++;
		Cow.checkAndAction();
		Farmer.checkAndAction();

		if (Cow.location_X == Farmer.location_X && Cow.location_Y == Farmer.location_Y)
		{
			cout << times << endl;
			break;
		}
	}
}
```