https://www.luogu.com.cn/problem/P1892

自己做题时的思考：

看题想到并查集
记录朋友关系
记录敌人关系
   

题解：
对于敌人关系，先记录两两为敌，再将一方的所有敌人与另一方合并（敌人的敌人是朋友）；
最终统计并查集中根节点的数量，就是最大团伙数。

最后的代码：

int f[1005];
int e[1005][1005];

int find(int x){
    return x==f[x]?x:f[x]=find(f[x]);
}
void union_(int a,int b){
    int u=find(a);
    int v=find(b);
    if(u!=v)f[u]=v;
}

int main(){
int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        f[i]=i;
    }
int p,q;
char opt;
    for(int i=1;i<=m;i++){
        cin>>opt>>p>>q;
            if(opt=='F')union_(p,q);
            else{
                e[p][q]=e[q][p]=1;
                for(int i=1;i<=n;i++){
                    if(e[p][i])union_(q,i);
                    if(e[q][i])union_(p,i);
                }
            }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(f[i]==i)ans++;
    }
    cout<<ans;
    return 0;
}

代码内容：

f[]:储存每个节点的父节点
e[][]:e[p][q]=1表示p和q互为敌人关系
find函数：找到节点的根节点（路径压缩）
union_函数：合并俩节点，使俩节点的根节点相同
