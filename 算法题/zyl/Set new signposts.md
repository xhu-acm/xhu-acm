# 洛谷 P3853 Set new signposts

## 题目描述：
有一条长长的高速公路，某些地方设有路标，但路标设得太少了，相邻两个路标之隔着相当长的距离。把公路上相邻路标的最大距离定义为该公路的“空旷指数”。

题目描述
在公路上增设一些路标，使得公路的“空旷指数”最小设计一个程序计算能达到的最小值是多少。
请注意，公路的起点和终点保证已设有标志，并且原有路标和新设路标都必须距起点整数个单位距离。

输入格式
第 1 行包括三个数 L,N,K，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。

第 2 行包括递增排列的 N 个整数，分别表示原有的 N 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 [0,L] 内。

输出格式
一个整数，表示增设路标后能达到的最小“空旷指数”值。

## 思路分解
1.要求是-----最大的空旷指数值最小（与洛谷P2678跳石头相反）
 空旷指数是相邻的最大值，求最小指数可以理解为---
 不大于K的情况且满足距离问题下，空旷指数数组中最小的
2.需要有一个来计数---要达到小于等于最大增设路标数，这也是check函数判断条件（2）
3.空旷指数是相邻路标之间的距离---节省时间可以使用差分数组先直接储存相邻路标距离
4.满足check函数返回值应为右值
5.关于check函数，要满足的是新插入后的差分数组距离不大于mid值，这是check函数条件（1）。同时计数值要判断
6.用到枚举时间超出---用到二分法之二分答案

## 代码实现
### c++实现
#include<iostream>
using namespace std;
const int N = 100010;
int   L, n,K;
int   a[N], diff[N];//a来记录已知路标值，diff--差分数组
bool check(int dis);
int main(){
	cin >> L >> n >> K;
for (int i = 1; i <= n; i++) {
	cin >> a[i];
	}
for (int i = 1; i <= n; i++) {
	diff[i] = a[i] - a[i - 1];
}//差分数组记录
a[n + 1] = L;//要到的不是最后一个路标，而是最终点
diff[n + 1] = a[n + 1] - a[n];
int l = 0; int r = L + 1;//二分法，0和L+1保证刚开始判断不受影响
while (l + 1 < r) {
	int m = (l+r)/ 2;
	if (check(m)) {
		r = m;
	}
	else {
		l = m;
	}
}
cout << r;//最小空旷指数
	return  0;
}
bool check(int dis) {
	int count = 0;//计数器--添加的路标数
	for (int i = 1; i <= n + 1; i++) {//
		if (diff[i] > dis) {//间隔更大则需添加路标-------条件（1）
			int diff1 = diff[i];//差分数组值需保值
			while (diff1 > dis) {//这里来保证间隔不大于dis值
				count++;
				diff1 -= dis;
			}
		}
	}
	if (count <= K) { return true; }//条件（2）
	else { return false; }
}

## 复杂度分析
时间 O(nLogL) 空间  O(n)