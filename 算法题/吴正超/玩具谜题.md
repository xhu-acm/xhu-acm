[玩具谜题]： https://www.luogu.com.cn/problem/P1563 
题目简述：
本题给出若干(<1e5)围成圆形的玩具，面朝不同方向，从第一个玩具开始进行有限数次(<1e5)有向操作，找到最后一次操作后指向的玩具。
思考：
本题的难点主要在于玩具每次操作后确定指向玩具的下标，对于环形来说可以用链表省去确定下标的步骤，但在比赛中链表的动态内存累计在面对大数据量时很容易超过内存限制，所以通过构造全局静态数组的方式储存数据的方法更好。
解题：先建立玩具的结构体，分析得到当代表玩具的面朝方向的数字(0,1)和代表操作方向(0,1)的数字相同时均顺时针方向移动，否则逆时针方向移动，在移动时如果超过了边界要确定真正的下标。
代码：
#include<iostream>
#include<string>
using namespace std;
#define max 100000
struct pep//创建玩具的结构体
{
    string name;
    bool face;
};
struct test//由于数据量较大，所以在对操作的朝向和步子建立结构体存储
{
    int turn;
    int tap;
};
pep a[max];
test b[max];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> a[i].face >> a[i].name;
    int aim = 0;
    for (int i = 0; i < m; i++)
    {
        cin >> b[i].turn >> b[i].tap;
        if (a[aim].face == b[i].turn)//朝向和移动方向相同时逆时针
        {
            aim = (n + aim - b[i].tap) % (n);//超过边界时进行此操作
        }
        else//否则顺时针
            aim = (aim + b[i].tap) % (n);
    }
    cout << a[aim].name;//输出最后一次操作后指向的玩具的名称
    return 0;
}